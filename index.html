<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
html,body{margin:0;height:100%;background:#000;overflow:hidden;}
#earth-container{width:100%;height:100%;touch-action:none;}
#earth-container canvas{display:block;touch-action:none;-webkit-user-select:none;user-select:none;}
#search{
position:absolute;
top:15px;
left:50%;
transform:translateX(-50%);
padding:8px;
z-index:10;
background:#111;
border:none;
color:#fff;
outline:none;
}
</style>
</head>
<body>

<input id="search" placeholder="Name suchen...">
<div id="earth-container"></div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js";

const supabase=window.supabase.createClient(
"https://pbgrlhpevbhsdyifowro.supabase.co",
"sb_publishable_tZvZAZrr0GBaq70GVn_fbA_NMlioioG"
);

const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(45,innerWidth/innerHeight,0.1,1000);
camera.position.set(0,0,3.8);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.outputColorSpace=THREE.SRGBColorSpace;
renderer.domElement.style.touchAction="none";
document.getElementById("earth-container").appendChild(renderer.domElement);

const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2();
const clickablePlanes=[];
let openedPlane=null;
let loadedIds=new Set();
let lastSpotCount = 0;
let dragging=false;
let lastX=0,lastY=0;
let activePointerId=null;
let dragMoved=false;
let dragStartX=0,dragStartY=0;
const DRAG_THRESHOLD_PX=6;
let touchHoverPlane=null;
const isMobile=/Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

const loader=new THREE.TextureLoader();
const earthGroup=new THREE.Group();
scene.add(earthGroup);

scene.add(new THREE.AmbientLight(0xffffff,0.4));

/* ðŸŒŒ STARS */
const starGeo=new THREE.BufferGeometry();
const verts=[];
for(let i=0;i<7000;i++){
verts.push(
THREE.MathUtils.randFloatSpread(200),
THREE.MathUtils.randFloatSpread(200),
THREE.MathUtils.randFloatSpread(200)
)}
starGeo.setAttribute("position",
new THREE.Float32BufferAttribute(verts,3));

scene.add(new THREE.Points(
starGeo,
new THREE.PointsMaterial({
color:0xffffff,
size:0.4,
map:new THREE.TextureLoader().load("https://threejs.org/examples/textures/sprites/disc.png"),
transparent:true,
alphaTest:0.5
})
));

/* EARTH */
const earthTex=loader.load("./assets/earth_night.jpg");
earthTex.colorSpace=THREE.SRGBColorSpace;

earthGroup.add(new THREE.Mesh(
new THREE.SphereGeometry(1,64,64),
new THREE.MeshPhongMaterial({map:earthTex})
));

/* CITY LIGHTS */
const lightTex=loader.load("https://cdn.jsdelivr.net/gh/mrdoob/three.js@r160/examples/textures/planets/earth_lights_2048.png");
lightTex.colorSpace=THREE.SRGBColorSpace;

earthGroup.add(new THREE.Mesh(
new THREE.SphereGeometry(1.002,64,64),
new THREE.MeshBasicMaterial({
map:lightTex,
transparent:true,
blending:THREE.AdditiveBlending,
depthWrite:false
})
));

/* CLOUDS */
const clouds=new THREE.Mesh(
new THREE.SphereGeometry(1.01,64,64),
new THREE.MeshBasicMaterial({
map:loader.load("https://cdn.jsdelivr.net/gh/mrdoob/three.js@r160/examples/textures/planets/earth_clouds_1024.png"),
transparent:true,
opacity:0.35
})
);
earthGroup.add(clouds);

/* SPOTS */
async function loadApprovedSpots(){
    const previousCount = loadedIds.size;   
const {data}=await supabase
.from("spots")
.select("id,image_url,link_url,name")
.eq("approved",true);

data.forEach((spot)=>{

if(loadedIds.has(spot.id))return;
loadedIds.add(spot.id);

const tex=loader.load(spot.image_url);
tex.anisotropy=renderer.capabilities.getMaxAnisotropy();

const plane=new THREE.Mesh(
    new THREE.CircleGeometry(0.06,32),
new THREE.MeshBasicMaterial({
    map: tex,
    transparent: true,
    side: THREE.DoubleSide,
    toneMapped: false
})
);
const baseScale=isMobile?0.4:0.25;
plane.scale.set(baseScale,baseScale,1);

const lat=(Math.random()-0.5)*Math.PI;
const lon=Math.random()*Math.PI*2;
const r=1;

plane.position.set(
r*Math.cos(lat)*Math.cos(lon),
r*Math.sin(lat),
r*Math.cos(lat)*Math.sin(lon)
);

const normal=plane.position.clone().normalize();
plane.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1),normal);
plane.position.add(normal.multiplyScalar(0.12));

plane.userData={
opened:false,
hover:false,
name:(spot.name||"").toLowerCase(),
link:spot.link_url,
baseScale,
originalPosition:plane.position.clone(),
originalQuaternion:plane.quaternion.clone()
};

clickablePlanes.push(plane);
earthGroup.add(plane);
});

const newCount = loadedIds.size - previousCount;

if(previousCount > 0 && newCount > 0){
    showNewSpotsBadge(newCount);
}

}
function showNewSpotsBadge(count){

const badge = document.createElement("div");
badge.textContent = `+${count} neue Spots`;
badge.style.position = "absolute";
badge.style.top = "20px";
badge.style.right = "20px";
badge.style.padding = "6px 12px";
badge.style.background = "rgba(255,255,255,0.08)";
badge.style.color = "#fff";
badge.style.fontSize = "13px";
badge.style.borderRadius = "20px";
badge.style.backdropFilter = "blur(6px)";
badge.style.opacity = "0";
badge.style.transition = "opacity 0.6s ease";
badge.style.zIndex = "20";

document.body.appendChild(badge);

requestAnimationFrame(()=>badge.style.opacity="1");

setTimeout(()=>{
badge.style.opacity="0";
setTimeout(()=>badge.remove(),600);
},4000);

}
loadApprovedSpots();
setInterval(loadApprovedSpots,10000);

/* HOVER DESKTOP */
renderer.domElement.addEventListener("mousemove",(e)=>{
mouse.x=(e.clientX/innerWidth)*2-1;
mouse.y=-(e.clientY/innerHeight)*2+1;
raycaster.setFromCamera(mouse,camera);
const i=raycaster.intersectObjects(clickablePlanes);
clickablePlanes.forEach(p=>{
if(!p.userData.opened)p.scale.set(p.userData.baseScale,p.userData.baseScale,1);
});
if(i.length>0&&!i[0].object.userData.opened)
i[0].object.scale.set(0.85,0.85,1);
});



function updateTouchHover(clientX,clientY){

mouse.x=(clientX/innerWidth)*2-1;
mouse.y=-(clientY/innerHeight)*2+1;
raycaster.setFromCamera(mouse,camera);

const i=raycaster.intersectObjects(clickablePlanes);
const next=(i.length>0)?i[0].object:null;

if(touchHoverPlane && touchHoverPlane!==next){
resetMobilePreview(touchHoverPlane);
}

touchHoverPlane = next;

if(touchHoverPlane && !touchHoverPlane.userData.opened){
mobilePreview(touchHoverPlane);
}

}
/* TAP + CLICK */
renderer.domElement.addEventListener("pointerdown",(e)=>{
if(e.pointerType==="mouse" && e.button!==0) return;
activePointerId=e.pointerId;
if(isMobile){
dragging=false;
}else{
dragging=true;
}
if(isMobile){
dragging=false;
}else{

}
try{renderer.domElement.setPointerCapture(activePointerId);}catch{}

dragMoved=false;
dragStartX=lastX=e.clientX;
dragStartY=lastY=e.clientY;
if(e.pointerType!=="mouse") updateTouchHover(e.clientX,e.clientY);
if(isMobile){
mouse.x=(e.clientX/innerWidth)*2-1;
mouse.y=-(e.clientY/innerHeight)*2+1;
raycaster.setFromCamera(mouse,camera);
const i=raycaster.intersectObjects(clickablePlanes);

if(i.length>0){
touchHoverPlane=i[0].object;
mobilePreview(touchHoverPlane);
}
}
});

renderer.domElement.addEventListener("pointermove",(e)=>{

if(e.pointerId!==activePointerId) return;

const dx=e.clientX-lastX;
const dy=e.clientY-lastY;

if(!dragMoved){
    const ddx=e.clientX-dragStartX;
    const ddy=e.clientY-dragStartY;

    if((ddx*ddx+ddy*ddy)>(DRAG_THRESHOLD_PX*DRAG_THRESHOLD_PX)){
        dragMoved=true;

        if(isMobile){
            dragging=true;

            if(touchHoverPlane){
                resetMobilePreview(touchHoverPlane);
                touchHoverPlane=null;
            }
        }
    }
}

if(dragging){
    earthGroup.rotation.y+=dx*0.005;
    earthGroup.rotation.x+=dy*0.003;
}

lastX=e.clientX;
lastY=e.clientY;

});

function endPointer(e){
if(e.pointerId!==activePointerId) return;
try{renderer.domElement.releasePointerCapture(activePointerId);}catch{}
dragging=false;
activePointerId=null;
if(touchHoverPlane && !touchHoverPlane.userData.opened){
touchHoverPlane.scale.set(touchHoverPlane.userData.baseScale,touchHoverPlane.userData.baseScale,1);
}
touchHoverPlane=null;

// Drag should not trigger "tap/click" behavior.
if(dragMoved) return;

mouse.x=(e.clientX/innerWidth)*2-1;
mouse.y=-(e.clientY/innerHeight)*2+1;
raycaster.setFromCamera(mouse,camera);
const i=raycaster.intersectObjects(clickablePlanes);

if(i.length===0){
if(openedPlane){
flyBack(openedPlane);
openedPlane=null;
}
return;
}

const p=i[0].object;

if(!p.userData.opened){
flyToCamera(p);
p.userData.opened=true;
openedPlane=p;
}else{
window.open(p.userData.link,"_blank");
}
}
renderer.domElement.addEventListener("pointerup",endPointer);
renderer.domElement.addEventListener("pointercancel",endPointer);

function flyToCamera(mesh){

earthGroup.remove(mesh);

const texture = mesh.material.map;

const group = new THREE.Group();
scene.add(group);
const particleCount = 280;
const dir = new THREE.Vector3();
camera.getWorldDirection(dir);
const target = camera.position.clone().add(dir.multiplyScalar(1.6));

for(let i=0;i<particleCount;i++){

    const piece = new THREE.Mesh(
        new THREE.PlaneGeometry(0.04,0.04),  
        new THREE.MeshBasicMaterial({
            map:texture,
            transparent:true,
            side:THREE.DoubleSide
        })
    );

    piece.position.copy(mesh.position);
    piece.position.x += (Math.random()-0.5)*1.5;
    piece.position.y += (Math.random()-0.5)*1.5;
    piece.position.z += (Math.random()-0.5)*1.5;

    piece.rotation.set(
        Math.random()*Math.PI,
        Math.random()*Math.PI,
        Math.random()*Math.PI
    );

    group.add(piece);

    gsap.to(piece.position,{
        x:target.x,
        y:target.y,
        z:target.z,
        duration:1.6,
        ease:"power3.out"
    });

    gsap.to(piece.rotation,{
        x:0,y:0,z:0,
        duration:1.6,
        ease:"power3.out"
    });
}

mesh.visible = false;

setTimeout(()=>{

    group.clear();
    scene.remove(group);

    mesh.position.copy(target);
    mesh.lookAt(camera.position);
    mesh.scale.set(2,2,2);
    mesh.visible = true;
    scene.add(mesh);

},1700);

}

function flyBack(mesh){
scene.remove(mesh);
earthGroup.add(mesh);
mesh.position.copy(mesh.userData.originalPosition);
mesh.quaternion.copy(mesh.userData.originalQuaternion);
mesh.scale.set(mesh.userData.baseScale,mesh.userData.baseScale,mesh.userData.baseScale);
mesh.userData.opened=false;
}

/* SEARCH */
document.getElementById("search")
.addEventListener("input",(e)=>{
const q=e.target.value.toLowerCase();
clickablePlanes.forEach(p=>{
if(p.userData.name.includes(q)&&q.length>1){
const v=p.userData.originalPosition.clone().normalize();
earthGroup.rotation.y=-Math.atan2(v.x,v.z);
earthGroup.rotation.x=Math.asin(v.y);
}
});
});

/* ANIMATE */
function animate(){
requestAnimationFrame(animate);
if(!dragging) earthGroup.rotation.y+=0.0014;
clouds.rotation.y+=0.003;
camera.lookAt(earthGroup.position);
renderer.render(scene,camera);
}
animate();

addEventListener("resize",()=>{
camera.aspect=innerWidth/innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
