<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
html,body{margin:0;height:100%;background:#000;overflow:hidden;}
#earth-container{width:100%;height:100%;touch-action:none;}
#earth-container canvas{display:block;touch-action:none;-webkit-user-select:none;user-select:none;}
#search{
position:absolute;
top:15px;
left:50%;
transform:translateX(-50%);
padding:8px;
z-index:10;
background:#111;
border:none;
color:#fff;
outline:none;
}
</style>
</head>
<body>

<input id="search" placeholder="Name suchen...">
<div id="earth-container"></div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js";

const supabase = window.supabase.createClient(
  "https://vxucflqzkjzchjlibmvh.supabase.co",
  "sb_publishable_Sm8B9jYs3nmxo7ojSFQKxA_go0uK86L"
);

const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(45,innerWidth/innerHeight,0.1,1000);
camera.position.set(0,0,3.8);
let spotMeta = [];

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.outputColorSpace=THREE.SRGBColorSpace;
renderer.domElement.style.touchAction="none";
document.getElementById("earth-container").appendChild(renderer.domElement);

const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2();


let instancedMarkers=null;
let searchQuery="";
let searchTargetIndex=null;
let appState="idle";
let openedImageMesh=null;
let openedIndex=null;
let previewMesh=null;
let markerPositions = [];



let dragging=false;
let lastX=0,lastY=0;
let activePointerId=null;

const loader=new THREE.TextureLoader();
const earthGroup=new THREE.Group();
scene.add(earthGroup);

scene.add(new THREE.AmbientLight(0xffffff,0.4));
const dirLight=new THREE.DirectionalLight(0xffffff,1.2);
dirLight.position.set(3,2,5);
scene.add(dirLight);

/* STARS */
const starGeo=new THREE.BufferGeometry();
const verts=[];
for(let i=0;i<7000;i++){
verts.push(
THREE.MathUtils.randFloatSpread(200),
THREE.MathUtils.randFloatSpread(200),
THREE.MathUtils.randFloatSpread(200)
)}
starGeo.setAttribute("position",
new THREE.Float32BufferAttribute(verts,3));
scene.add(new THREE.Points(
starGeo,
new THREE.PointsMaterial({
color:0xffffff,
size:0.4,
map:new THREE.TextureLoader().load("https://threejs.org/examples/textures/sprites/disc.png"),
transparent:true,
alphaTest:0.5
})
));

/* EARTH */
const earthTex=loader.load("./assets/earth_night.jpg");
earthTex.colorSpace=THREE.SRGBColorSpace;
earthGroup.add(new THREE.Mesh(
new THREE.SphereGeometry(1,64,64),
new THREE.MeshPhongMaterial({map:earthTex})
));

/* CITY LIGHTS */
const lightTex=loader.load("https://cdn.jsdelivr.net/gh/mrdoob/three.js@r160/examples/textures/planets/earth_lights_2048.png");
lightTex.colorSpace=THREE.SRGBColorSpace;
earthGroup.add(new THREE.Mesh(
new THREE.SphereGeometry(1.002,64,64),
new THREE.MeshBasicMaterial({
map:lightTex,
transparent:true,
blending:THREE.AdditiveBlending,
depthWrite:false
})
));

/* CLOUDS */
const clouds=new THREE.Mesh(
new THREE.SphereGeometry(1.01,64,64),
new THREE.MeshBasicMaterial({
map:loader.load("https://cdn.jsdelivr.net/gh/mrdoob/three.js@r160/examples/textures/planets/earth_clouds_1024.png"),
transparent:true,
opacity:0.35
})
);
earthGroup.add(clouds);

/* SPOTS */
async function loadApprovedSpots(){

const { data } = await supabase
.from("spots")
.select("id,image_url,link_url,name")
.eq("approved", true);

if(!data) return;

spotMeta=data;

const geometry=new THREE.SphereGeometry(0.015,16,16);
const material=new THREE.MeshStandardMaterial({
color:0xffffff,
emissive:0x666666,
metalness:0.9,
roughness:0.25
});

instancedMarkers=new THREE.InstancedMesh(
geometry,
material,
data.length
);

const dummy=new THREE.Object3D();

for(let i=0;i<data.length;i++){

const lat=(Math.random()-0.5)*Math.PI;
const lon=Math.random()*Math.PI*2;
const r=1;

dummy.position.set(
r*Math.cos(lat)*Math.cos(lon),
r*Math.sin(lat),
r*Math.cos(lat)*Math.sin(lon)
);

const normal=dummy.position.clone().normalize();
dummy.position.add(normal.multiplyScalar(0.12));
dummy.lookAt(normal.clone().multiplyScalar(2));
dummy.updateMatrix();

instancedMarkers.setMatrixAt(i,dummy.matrix);
markerPositions.push(dummy.position.clone());
}

earthGroup.add(instancedMarkers);
}
loadApprovedSpots();
document.getElementById("search").addEventListener("keydown",(e)=>{

if(e.key !== "Enter") return;
if(!instancedMarkers) return;

const query = e.target.value.toLowerCase();
if(query === "") return;

let foundIndex = null;

for(let i=0;i<spotMeta.length;i++){
    const name = spotMeta[i]?.name?.toLowerCase() || "";
    if(name.includes(query)){
        foundIndex = i;
        break;
    }
}

if(foundIndex === null) return;

const matrix = new THREE.Matrix4();
instancedMarkers.getMatrixAt(foundIndex, matrix);

const pos = new THREE.Vector3();
pos.setFromMatrixPosition(matrix);
pos.applyMatrix4(instancedMarkers.matrixWorld);

const earthPos = new THREE.Vector3();
earthGroup.getWorldPosition(earthPos);

const dir = pos.clone().sub(earthPos).normalize();

const camTarget = earthPos.clone().add(dir.multiplyScalar(3.2));

gsap.to(camera.position,{
    x:camTarget.x,
    y:camTarget.y,
    z:camTarget.z,
    duration:1.4,
    ease:"power3.inOut",
    onUpdate:()=>{
        camera.lookAt(earthPos);
    }
});

});





/* POINTER */
renderer.domElement.addEventListener("pointerdown",(e)=>{
activePointerId=e.pointerId;
dragging=true;
lastX=e.clientX;
lastY=e.clientY;
});

renderer.domElement.addEventListener("pointermove",(e)=>{

if(dragging){
earthGroup.rotation.y+=(e.clientX-lastX)*0.005;
earthGroup.rotation.x+=(e.clientY-lastY)*0.003;
lastX=e.clientX;
lastY=e.clientY;
return;
}

if(!instancedMarkers) return;

mouse.x=(e.clientX/innerWidth)*2-1;
mouse.y=-(e.clientY/innerHeight)*2+1;
raycaster.setFromCamera(mouse,camera);


const intersects = raycaster.intersectObject(instancedMarkers,false);
if(intersects.length===0){
if(previewMesh){scene.remove(previewMesh);previewMesh=null;}
return;
}

const index=intersects[0].instanceId;

loader.load(spotMeta[index].image_url,(texture)=>{
if(previewMesh) scene.remove(previewMesh);
previewMesh=new THREE.Mesh(
new THREE.CircleGeometry(0.07,32),
new THREE.MeshBasicMaterial({map:texture,transparent:true})
);
previewMesh.position.copy(camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(1.8)));
previewMesh.lookAt(camera.position);
scene.add(previewMesh);
});
});

renderer.domElement.addEventListener("pointerup",(e)=>{

dragging=false;

mouse.x=(e.clientX/innerWidth)*2-1;
mouse.y=-(e.clientY/innerHeight)*2+1;
raycaster.setFromCamera(mouse,camera);

// ðŸ”´ BILD SCHLIESSEN WENN DANEBEN GEKLICKT
// ðŸ”´ BILD SCHLIESSEN (egal wo geklickt wird)
if(appState==="open" && openedImageMesh){

const hitImage = raycaster.intersectObject(openedImageMesh);

// ðŸ‘‰ Klick AUF Bild = NICHT schlieÃŸen
if(hitImage.length>0){
    return;
}

// ðŸ‘‰ Klick DANEBEN = schlieÃŸen
scene.remove(openedImageMesh);
openedImageMesh=null;
openedIndex=null;
appState="idle";
return;
}

if(!instancedMarkers) return;

const intersects=raycaster.intersectObject(instancedMarkers);
if(intersects.length===0) return;

const index=intersects[0].instanceId;
openedIndex=index;
appState="open";

loader.load(spotMeta[index].image_url,(texture)=>{

const matrix=new THREE.Matrix4();
instancedMarkers.getMatrixAt(index,matrix);
const position = new THREE.Vector3();
position.setFromMatrixPosition(matrix);

// ðŸ”´ GANZ WICHTIG

// ðŸ‘‰ Local â†’ World transformieren
position.applyMatrix4(instancedMarkers.matrixWorld);
const group=new THREE.Group();
scene.add(group);

const dir=new THREE.Vector3();
camera.getWorldDirection(dir);
const target=camera.position.clone().add(dir.multiplyScalar(1.6));

const particleCount = 220;

for(let i=0;i<particleCount;i++){

    const piece = new THREE.Mesh(
        new THREE.PlaneGeometry(0.05,0.05),
        new THREE.MeshBasicMaterial({
            map:texture,
            transparent:true,
            side:THREE.DoubleSide
        })
    );

    piece.position.copy(position);

    const explosionDir = new THREE.Vector3(
        (Math.random()-0.5),
        (Math.random()-0.5),
        (Math.random()-0.5)
    ).normalize();

    const strength = 0.6 + Math.random()*0.8;

    piece.position.add(explosionDir.multiplyScalar(strength));

    piece.rotation.set(
        Math.random()*Math.PI,
        Math.random()*Math.PI,
        Math.random()*Math.PI
    );

    group.add(piece);

    gsap.to(piece.position,{
        x:target.x,
        y:target.y,
        z:target.z,
        delay:0.4,
        duration:1.2,
        ease:"power3.inOut"
    });

    gsap.to(piece.rotation,{
        x:0,y:0,z:0,
        duration:1.6,
        ease:"power3.out"
    });
}

setTimeout(()=>{
group.clear();
scene.remove(group);
openedImageMesh=new THREE.Mesh(
new THREE.CircleGeometry(0.18,64),
new THREE.MeshBasicMaterial({map:texture,transparent:true})
);

openedImageMesh.position.copy(target);
openedImageMesh.lookAt(camera.position);
scene.add(openedImageMesh);
appState="open";
},1200);

});
});
renderer.domElement.addEventListener("dblclick",(e)=>{

if(appState!=="open" || !openedImageMesh) return;

mouse.x=(e.clientX/innerWidth)*2-1;
mouse.y=-(e.clientY/innerHeight)*2+1;
raycaster.setFromCamera(mouse,camera);

const hit=raycaster.intersectObject(openedImageMesh);
if(hit.length===0) return;

const spot=spotMeta[openedIndex];
if(spot?.link_url){
    window.open(spot.link_url,"_blank");
}

});
/* ANIMATE */
function animate(){
requestAnimationFrame(animate);

if(!dragging && searchTargetIndex === null){
    earthGroup.rotation.y += 0.0014;
}

clouds.rotation.y+=0.003;

/* Puls */
if(instancedMarkers){
const time=Date.now()*0.002;
const dummy=new THREE.Object3D();

for(let i=0;i<instancedMarkers.count;i++){
const matrix=new THREE.Matrix4();
instancedMarkers.getMatrixAt(i,matrix);
const pos=new THREE.Vector3();
const quat=new THREE.Quaternion();
const scl=new THREE.Vector3();
matrix.decompose(pos,quat,scl);

let strength=0.18;
if(i===searchTargetIndex) strength=0.45;

const pulse=1+strength*Math.sin(time);

dummy.position.copy(pos);
dummy.quaternion.copy(quat);
dummy.scale.set(pulse,pulse,pulse);
dummy.updateMatrix();
instancedMarkers.setMatrixAt(i,dummy.matrix);
}

instancedMarkers.instanceMatrix.needsUpdate=true;
}



 

camera.lookAt(earthGroup.position);
renderer.render(scene,camera);
}
animate();

</script>
</body>
</html>