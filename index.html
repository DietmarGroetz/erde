<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
html,body{margin:0;height:100%;background:#000;overflow:hidden;}
#earth-container{width:100%;height:100%;touch-action:none;}
#earth-container canvas{display:block;touch-action:none;-webkit-user-select:none;user-select:none;}
#search{
position:absolute;
top:15px;
left:50%;
transform:translateX(-50%);
padding:8px;
z-index:10;
background:#111;
border:none;
color:#fff;
outline:none;
}
</style>
</head>
<body>

<input id="search" placeholder="Name suchen...">
<div id="earth-container"></div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js";

const supabase=window.supabase.createClient(
"https://pbgrlhpevbhsdyifowro.supabase.co",
"sb_publishable_tZvZAZrr0GBaq70GVn_fbA_NMlioioG"
);

const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(45,innerWidth/innerHeight,0.1,1000);
camera.position.set(0,0,3.8);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.outputColorSpace=THREE.SRGBColorSpace;
renderer.domElement.style.touchAction="none";
document.getElementById("earth-container").appendChild(renderer.domElement);

const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2();
const clickablePlanes=[];
let openedPlane=null;
let openedImageMesh = null;
let loadedIds=new Set();
let spotMeta = [];
let appState = "idle"; 
// idle | hover | exploding | open

let hoveredMarker = null;
let openImageMesh = null;
let previewMesh = null;
let currentHoverMesh = null;
let dragging=false;
let lastX=0,lastY=0;
let activePointerId=null;
let dragMoved=false;
let dragStartX=0,dragStartY=0;
const DRAG_THRESHOLD_PX=6;
let touchHoverPlane=null;
const isMobile=/Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

const loader=new THREE.TextureLoader();
const earthGroup=new THREE.Group();
scene.add(earthGroup);

scene.add(new THREE.AmbientLight(0xffffff,0.4));
const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
dirLight.position.set(3, 2, 5);
scene.add(dirLight);
/* ðŸŒŒ STARS */
const starGeo=new THREE.BufferGeometry();
const verts=[];
for(let i=0;i<7000;i++){
verts.push(
THREE.MathUtils.randFloatSpread(200),
THREE.MathUtils.randFloatSpread(200),
THREE.MathUtils.randFloatSpread(200)
)}
starGeo.setAttribute("position",
new THREE.Float32BufferAttribute(verts,3));

scene.add(new THREE.Points(
starGeo,
new THREE.PointsMaterial({
color:0xffffff,
size:0.4,
map:new THREE.TextureLoader().load("https://threejs.org/examples/textures/sprites/disc.png"),
transparent:true,
alphaTest:0.5
})
));

/* EARTH */
const earthTex=loader.load("./assets/earth_night.jpg");
earthTex.colorSpace=THREE.SRGBColorSpace;

earthGroup.add(new THREE.Mesh(
new THREE.SphereGeometry(1,64,64),
new THREE.MeshPhongMaterial({map:earthTex})
));

/* CITY LIGHTS */
const lightTex=loader.load("https://cdn.jsdelivr.net/gh/mrdoob/three.js@r160/examples/textures/planets/earth_lights_2048.png");
lightTex.colorSpace=THREE.SRGBColorSpace;

earthGroup.add(new THREE.Mesh(
new THREE.SphereGeometry(1.002,64,64),
new THREE.MeshBasicMaterial({
map:lightTex,
transparent:true,
blending:THREE.AdditiveBlending,
depthWrite:false
})
));

/* CLOUDS */
const clouds=new THREE.Mesh(
new THREE.SphereGeometry(1.01,64,64),
new THREE.MeshBasicMaterial({
map:loader.load("https://cdn.jsdelivr.net/gh/mrdoob/three.js@r160/examples/textures/planets/earth_clouds_1024.png"),
transparent:true,
opacity:0.35
})
);
earthGroup.add(clouds);

/* SPOTS */
async function loadApprovedSpots(){
    
    const { data, error } = await supabase
    .from("spots")
    .select("id,image_url,link_url,name")
    .eq("approved", true);

if (error) {
    console.log(error);
    return;
}

if (!data || data.length === 0) {
    console.log("No spots found");
    return;
}

spotMeta = data;

data.forEach((spot)=>{

if(loadedIds.has(spot.id))return;
loadedIds.add(spot.id);

const marker = new THREE.Mesh(
    new THREE.SphereGeometry(0.015, 16, 16),
    new THREE.MeshStandardMaterial({
        color: 0xb0b0b0,
        metalness: 0.9,
        roughness: 0.25
    })
);

const lat=(Math.random()-0.5)*Math.PI;
const lon=Math.random()*Math.PI*2;
const r=1;

marker.position.set(
r*Math.cos(lat)*Math.cos(lon),
r*Math.sin(lat),
r*Math.cos(lat)*Math.sin(lon)
);

const normal = marker.position.clone().normalize();
marker.quaternion.setFromUnitVectors(
    new THREE.Vector3(0,0,1),
    normal
);

marker.position.add(normal.multiplyScalar(0.12));

marker.userData = {

hover:false,
name:(spot.name||"").toLowerCase(),
link:spot.link_url,
baseScale: 1,
originalPosition: marker.position.clone(),
originalQuaternion: marker.quaternion.clone()
};

clickablePlanes.push(marker);
earthGroup.add(marker);

});
}
loadApprovedSpots();
setInterval(loadApprovedSpots,10000);



function updateTouchHover(clientX,clientY){
mouse.x=(clientX/innerWidth)*2-1;
mouse.y=-(clientY/innerHeight)*2+1;
raycaster.setFromCamera(mouse,camera);
const i=raycaster.intersectObjects(clickablePlanes);
const next=(i.length>0)?i[0].object:null;

if(touchHoverPlane && touchHoverPlane!==next && !touchHoverPlane.userData.opened){
touchHoverPlane.scale.set(touchHoverPlane.userData.baseScale,touchHoverPlane.userData.baseScale,1);
}
touchHoverPlane=next;
if(touchHoverPlane && !touchHoverPlane.userData.opened){
touchHoverPlane.scale.set(0.6,0.6,1);
}
}

/* TAP + CLICK */
renderer.domElement.addEventListener("pointerdown",(e)=>{
if(e.pointerType==="mouse" && e.button!==0) return;
activePointerId=e.pointerId;
try{renderer.domElement.setPointerCapture(activePointerId);}catch{}
dragging=true;
dragMoved=false;
dragStartX=lastX=e.clientX;
dragStartY=lastY=e.clientY;
if(e.pointerType!=="mouse") updateTouchHover(e.clientX,e.clientY);
});

renderer.domElement.addEventListener("pointermove",(e)=>{

// ----- Hover Teil -----
if(e.pointerType === "mouse") {

    mouse.x = (e.clientX / innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(clickablePlanes);

    if (intersects.length === 0) {
        removePreview();
    } else {

        const mesh = intersects[0].object;

        if (mesh !== currentHoverMesh) {

            currentHoverMesh = mesh;

            const index = clickablePlanes.indexOf(mesh);
            const spot = spotMeta[index];
            if (!spot) return;

            loader.load(spot.image_url, (texture) => {

                removePreview();

                const geometry = new THREE.CircleGeometry(0.07, 32);

                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    side: THREE.DoubleSide
                });

                previewMesh = new THREE.Mesh(geometry, material);

                const dir = new THREE.Vector3();
camera.getWorldDirection(dir);

previewMesh.position.copy(
    camera.position.clone().add(
        dir.multiplyScalar(1.4)
    )
);

previewMesh.lookAt(camera.position);    

                scene.add(previewMesh);
            });
        }
    }
}

// ----- Drag Teil -----
if(!dragging || e.pointerId !== activePointerId) return;

const dx = e.clientX - lastX;
const dy = e.clientY - lastY;

earthGroup.rotation.y += dx * 0.005;
earthGroup.rotation.x += dy * 0.003;

lastX = e.clientX;
lastY = e.clientY;

});

function endPointer(e){

if(e.pointerId !== activePointerId) return;
if(appState === "exploding") return;

try{
    renderer.domElement.releasePointerCapture(activePointerId);
}catch{}

dragging = false;
activePointerId = null;

if(dragMoved) return;

mouse.x = (e.clientX/innerWidth)*2 - 1;
mouse.y = -(e.clientY/innerHeight)*2 + 1;

raycaster.setFromCamera(mouse,camera);
const intersects = raycaster.intersectObjects(clickablePlanes);

// ----- Klick ins Leere -----
if(intersects.length === 0){

    if(appState === "open" && openedImageMesh){

        scene.remove(openedImageMesh);
        openedImageMesh.geometry.dispose();
        openedImageMesh.material.map.dispose();
        openedImageMesh.material.dispose();
        openedImageMesh = null;

        appState = "idle";
    }

    return;
}

const p = intersects[0].object;

// ----- Bild ist offen â†’ URL Ã¶ffnen -----
if(appState === "open"){

    if(p.userData.link){
        console.log("Link:", p.userData.link); 
        window.open(p.userData.link, "_blank");
    }

    return;
}

// ----- Normaler Klick â†’ Explosion -----
if(appState === "idle"){
    flyToCamera(p);
}
}

renderer.domElement.addEventListener("pointerup",endPointer);
renderer.domElement.addEventListener("pointercancel",endPointer);

function flyToCamera(mesh){


    appState = "exploding";
const index = clickablePlanes.indexOf(mesh);
const spot = spotMeta[index];
if(!spot) return;

loader.load(spot.image_url, (texture)=>{

const group = new THREE.Group();
scene.add(group);

const dir = new THREE.Vector3();
camera.getWorldDirection(dir);
const target = camera.position.clone().add(dir.multiplyScalar(1.6));

const particleCount = 220;

for(let i=0;i<particleCount;i++){

    const piece = new THREE.Mesh(
        new THREE.PlaneGeometry(0.05,0.05),
        new THREE.MeshBasicMaterial({
            map:texture,
            transparent:true,
            side:THREE.DoubleSide
        })
    );

    piece.position.copy(mesh.position);

    // echte Explosion: radial nach auÃŸen
    const explosionDir = new THREE.Vector3(
        (Math.random()-0.5),
        (Math.random()-0.5),
        (Math.random()-0.5)
    ).normalize();

    const strength = 0.6 + Math.random()*0.8;

    piece.position.add(explosionDir.multiplyScalar(strength));

    piece.rotation.set(
        Math.random()*Math.PI,
        Math.random()*Math.PI,
        Math.random()*Math.PI
    );

    group.add(piece);

    // erst Explosion
    gsap.to(piece.position,{
        x: piece.position.x,
        y: piece.position.y,
        z: piece.position.z,
        duration:0.4,
        ease:"power2.out"
    });

    // dann Einsammeln zur Kamera
    gsap.to(piece.position,{
        x:target.x,
        y:target.y,
        z:target.z,
        delay:0.4,
        duration:1.2,
        ease:"power3.inOut"
    });

    gsap.to(piece.rotation,{
        x:0,y:0,z:0,
        duration:1.6,
        ease:"power3.out"
    });
}



setTimeout(()=>{

    group.clear();
    scene.remove(group);

    const finalMesh = new THREE.Mesh(
        new THREE.CircleGeometry(0.18, 64),
        new THREE.MeshBasicMaterial({
            map:texture,
            transparent:true,
            side:THREE.DoubleSide
        })
    );

    finalMesh.position.copy(target);
    finalMesh.lookAt(camera.position);
    openedImageMesh = finalMesh;
    scene.add(finalMesh);
    appState = "open";
},1600);

});
}

function removePreview() {

currentHoverMesh = null;

if (!previewMesh) return;

scene.remove(previewMesh);
previewMesh.geometry.dispose();
previewMesh.material.map.dispose();
previewMesh.material.dispose();
previewMesh = null;
}
function flyBack(mesh){
scene.remove(mesh);
earthGroup.add(mesh);
mesh.position.copy(mesh.userData.originalPosition);
mesh.quaternion.copy(mesh.userData.originalQuaternion);
mesh.scale.set(mesh.userData.baseScale,mesh.userData.baseScale,mesh.userData.baseScale);
mesh.userData.opened=false;
}

/* SEARCH */
document.getElementById("search")
.addEventListener("input",(e)=>{
const q=e.target.value.toLowerCase();
clickablePlanes.forEach(p=>{
if(p.userData.name.includes(q)&&q.length>1){
const v=p.userData.originalPosition.clone().normalize();
earthGroup.rotation.y=-Math.atan2(v.x,v.z);
earthGroup.rotation.x=Math.asin(v.y);
}
});
});

/* ANIMATE */
function animate(){
requestAnimationFrame(animate);
if(!dragging) {
    earthGroup.rotation.y += 0.0014;
}
clouds.rotation.y+=0.003;
camera.lookAt(earthGroup.position);
renderer.render(scene,camera);
}
animate();

addEventListener("resize",()=>{
camera.aspect=innerWidth/innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
